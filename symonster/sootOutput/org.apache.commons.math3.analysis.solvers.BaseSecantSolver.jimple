public abstract class org.apache.commons.math3.analysis.solvers.BaseSecantSolver extends org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver implements org.apache.commons.math3.analysis.solvers.BracketedUnivariateSolver
{
    protected static final double DEFAULT_ABSOLUTE_ACCURACY;
    private org.apache.commons.math3.analysis.solvers.AllowedSolution allowed;
    private final org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method method;

    protected void <init>(double, org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method)
    {
        org.apache.commons.math3.analysis.solvers.BaseSecantSolver r0;
        double d0;
        org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method r1;
        org.apache.commons.math3.analysis.solvers.AllowedSolution $r2;

        r0 := @this: org.apache.commons.math3.analysis.solvers.BaseSecantSolver;

        d0 := @parameter0: double;

        r1 := @parameter1: org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method;

        specialinvoke r0.<org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver: void <init>(double)>(d0);

        $r2 = <org.apache.commons.math3.analysis.solvers.AllowedSolution: org.apache.commons.math3.analysis.solvers.AllowedSolution ANY_SIDE>;

        r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: org.apache.commons.math3.analysis.solvers.AllowedSolution allowed> = $r2;

        r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method method> = r1;

        return;
    }

    protected void <init>(double, double, org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method)
    {
        org.apache.commons.math3.analysis.solvers.BaseSecantSolver r0;
        double d0, d1;
        org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method r1;
        org.apache.commons.math3.analysis.solvers.AllowedSolution $r2;

        r0 := @this: org.apache.commons.math3.analysis.solvers.BaseSecantSolver;

        d0 := @parameter0: double;

        d1 := @parameter1: double;

        r1 := @parameter2: org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method;

        specialinvoke r0.<org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver: void <init>(double,double)>(d0, d1);

        $r2 = <org.apache.commons.math3.analysis.solvers.AllowedSolution: org.apache.commons.math3.analysis.solvers.AllowedSolution ANY_SIDE>;

        r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: org.apache.commons.math3.analysis.solvers.AllowedSolution allowed> = $r2;

        r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method method> = r1;

        return;
    }

    protected void <init>(double, double, double, org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method)
    {
        org.apache.commons.math3.analysis.solvers.BaseSecantSolver r0;
        double d0, d1, d2;
        org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method r1;
        org.apache.commons.math3.analysis.solvers.AllowedSolution $r2;

        r0 := @this: org.apache.commons.math3.analysis.solvers.BaseSecantSolver;

        d0 := @parameter0: double;

        d1 := @parameter1: double;

        d2 := @parameter2: double;

        r1 := @parameter3: org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method;

        specialinvoke r0.<org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver: void <init>(double,double,double)>(d0, d1, d2);

        $r2 = <org.apache.commons.math3.analysis.solvers.AllowedSolution: org.apache.commons.math3.analysis.solvers.AllowedSolution ANY_SIDE>;

        r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: org.apache.commons.math3.analysis.solvers.AllowedSolution allowed> = $r2;

        r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method method> = r1;

        return;
    }

    public double solve(int, org.apache.commons.math3.analysis.UnivariateFunction, double, double, org.apache.commons.math3.analysis.solvers.AllowedSolution)
    {
        org.apache.commons.math3.analysis.solvers.BaseSecantSolver r0;
        int i0;
        org.apache.commons.math3.analysis.UnivariateFunction r1;
        double d0, d1, $d2, $d3, $d4, $d5;
        org.apache.commons.math3.analysis.solvers.AllowedSolution r2;

        r0 := @this: org.apache.commons.math3.analysis.solvers.BaseSecantSolver;

        i0 := @parameter0: int;

        r1 := @parameter1: org.apache.commons.math3.analysis.UnivariateFunction;

        d0 := @parameter2: double;

        d1 := @parameter3: double;

        r2 := @parameter4: org.apache.commons.math3.analysis.solvers.AllowedSolution;

        $d2 = d1 - d0;

        $d3 = 0.5 * $d2;

        $d4 = d0 + $d3;

        $d5 = virtualinvoke r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double,org.apache.commons.math3.analysis.solvers.AllowedSolution)>(i0, r1, d0, d1, $d4, r2);

        return $d5;
    }

    public double solve(int, org.apache.commons.math3.analysis.UnivariateFunction, double, double, double, org.apache.commons.math3.analysis.solvers.AllowedSolution)
    {
        org.apache.commons.math3.analysis.solvers.BaseSecantSolver r0;
        int i0;
        org.apache.commons.math3.analysis.UnivariateFunction r1;
        double d0, d1, d2, $d3;
        org.apache.commons.math3.analysis.solvers.AllowedSolution r2;

        r0 := @this: org.apache.commons.math3.analysis.solvers.BaseSecantSolver;

        i0 := @parameter0: int;

        r1 := @parameter1: org.apache.commons.math3.analysis.UnivariateFunction;

        d0 := @parameter2: double;

        d1 := @parameter3: double;

        d2 := @parameter4: double;

        r2 := @parameter5: org.apache.commons.math3.analysis.solvers.AllowedSolution;

        r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: org.apache.commons.math3.analysis.solvers.AllowedSolution allowed> = r2;

        $d3 = specialinvoke r0.<org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver: double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double)>(i0, r1, d0, d1, d2);

        return $d3;
    }

    public double solve(int, org.apache.commons.math3.analysis.UnivariateFunction, double, double, double)
    {
        org.apache.commons.math3.analysis.solvers.BaseSecantSolver r0;
        int i0;
        org.apache.commons.math3.analysis.UnivariateFunction r1;
        double d0, d1, d2, $d3;
        org.apache.commons.math3.analysis.solvers.AllowedSolution $r2;

        r0 := @this: org.apache.commons.math3.analysis.solvers.BaseSecantSolver;

        i0 := @parameter0: int;

        r1 := @parameter1: org.apache.commons.math3.analysis.UnivariateFunction;

        d0 := @parameter2: double;

        d1 := @parameter3: double;

        d2 := @parameter4: double;

        $r2 = <org.apache.commons.math3.analysis.solvers.AllowedSolution: org.apache.commons.math3.analysis.solvers.AllowedSolution ANY_SIDE>;

        $d3 = virtualinvoke r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: double solve(int,org.apache.commons.math3.analysis.UnivariateFunction,double,double,double,org.apache.commons.math3.analysis.solvers.AllowedSolution)>(i0, r1, d0, d1, d2, $r2);

        return $d3;
    }

    protected final double doSolve() throws org.apache.commons.math3.exception.ConvergenceException
    {
        org.apache.commons.math3.analysis.solvers.BaseSecantSolver r0;
        double d0, d1, d2, d3, d4, $d5, $d6, $d7, $d8, $d9, $d10, $d11, d12, d13, d14, d15, $d16, $d17, $d18, $d19, $d20, $d21, $d22, $d23, $d24, $d25;
        byte $b0, $b1, $b2, $b3, $b8, $b9, $b12, $b13, $b14, $b15, $b16;
        org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method $r1;
        int[] $r2, $r4, $r7;
        int $i4, $i5, $i6, $i7, $i10, $i11;
        org.apache.commons.math3.analysis.solvers.AllowedSolution $r3, $r6;
        org.apache.commons.math3.exception.MathInternalError $r5, $r8, $r10;
        org.apache.commons.math3.exception.ConvergenceException $r9;
        boolean z0, $z1;

        r0 := @this: org.apache.commons.math3.analysis.solvers.BaseSecantSolver;

        d12 = virtualinvoke r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: double getMin()>();

        d13 = virtualinvoke r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: double getMax()>();

        d14 = virtualinvoke r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: double computeObjectiveValue(double)>(d12);

        d15 = virtualinvoke r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: double computeObjectiveValue(double)>(d13);

        $b0 = d14 cmpl 0.0;

        if $b0 != 0 goto label01;

        return d12;

     label01:
        $b1 = d15 cmpl 0.0;

        if $b1 != 0 goto label02;

        return d13;

     label02:
        virtualinvoke r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: void verifyBracketing(double,double)>(d12, d13);

        d0 = virtualinvoke r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: double getFunctionValueAccuracy()>();

        d1 = virtualinvoke r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: double getAbsoluteAccuracy()>();

        d2 = virtualinvoke r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: double getRelativeAccuracy()>();

        z0 = 0;

     label03:
        $d5 = d13 - d12;

        $d7 = d15 * $d5;

        $d6 = d15 - d14;

        $d8 = $d7 / $d6;

        d3 = d13 - $d8;

        d4 = virtualinvoke r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: double computeObjectiveValue(double)>(d3);

        $b2 = d4 cmpl 0.0;

        if $b2 != 0 goto label04;

        return d3;

     label04:
        $d9 = d15 * d4;

        $b3 = $d9 cmpg 0.0;

        if $b3 >= 0 goto label07;

        d12 = d13;

        d14 = d15;

        if z0 != 0 goto label05;

        $z1 = 1;

        goto label06;

     label05:
        $z1 = 0;

     label06:
        z0 = $z1;

        goto label12;

     label07:
        $r2 = <org.apache.commons.math3.analysis.solvers.BaseSecantSolver$1: int[] $SwitchMap$org$apache$commons$math3$analysis$solvers$BaseSecantSolver$Method>;

        $r1 = r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method method>;

        $i4 = virtualinvoke $r1.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver$Method: int ordinal()>();

        $i5 = $r2[$i4];

        tableswitch($i5)
        {
            case 1: goto label08;
            case 2: goto label09;
            case 3: goto label10;
            default: goto label11;
        };

     label08:
        d14 = d14 * 0.5;

        goto label12;

     label09:
        $d10 = d15 + d4;

        $d11 = d15 / $d10;

        d14 = d14 * $d11;

        goto label12;

     label10:
        $b14 = d3 cmpl d13;

        if $b14 != 0 goto label12;

        $r9 = new org.apache.commons.math3.exception.ConvergenceException;

        specialinvoke $r9.<org.apache.commons.math3.exception.ConvergenceException: void <init>()>();

        throw $r9;

     label11:
        $r10 = new org.apache.commons.math3.exception.MathInternalError;

        specialinvoke $r10.<org.apache.commons.math3.exception.MathInternalError: void <init>()>();

        throw $r10;

     label12:
        d13 = d3;

        d15 = d4;

        $d16 = staticinvoke <org.apache.commons.math3.util.FastMath: double abs(double)>(d4);

        $b15 = $d16 cmpg d0;

        if $b15 > 0 goto label19;

        $r7 = <org.apache.commons.math3.analysis.solvers.BaseSecantSolver$1: int[] $SwitchMap$org$apache$commons$math3$analysis$solvers$AllowedSolution>;

        $r6 = r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: org.apache.commons.math3.analysis.solvers.AllowedSolution allowed>;

        $i10 = virtualinvoke $r6.<org.apache.commons.math3.analysis.solvers.AllowedSolution: int ordinal()>();

        $i11 = $r7[$i10];

        tableswitch($i11)
        {
            case 1: goto label13;
            case 2: goto label14;
            case 3: goto label15;
            case 4: goto label16;
            case 5: goto label17;
            default: goto label18;
        };

     label13:
        return d3;

     label14:
        if z0 == 0 goto label19;

        return d3;

     label15:
        if z0 != 0 goto label19;

        return d3;

     label16:
        $b13 = d4 cmpg 0.0;

        if $b13 > 0 goto label19;

        return d3;

     label17:
        $b12 = d4 cmpl 0.0;

        if $b12 < 0 goto label19;

        return d3;

     label18:
        $r8 = new org.apache.commons.math3.exception.MathInternalError;

        specialinvoke $r8.<org.apache.commons.math3.exception.MathInternalError: void <init>()>();

        throw $r8;

     label19:
        $d17 = d3 - d12;

        $d18 = staticinvoke <org.apache.commons.math3.util.FastMath: double abs(double)>($d17);

        $d19 = staticinvoke <org.apache.commons.math3.util.FastMath: double abs(double)>(d3);

        $d20 = d2 * $d19;

        $d21 = staticinvoke <org.apache.commons.math3.util.FastMath: double max(double,double)>($d20, d1);

        $b16 = $d18 cmpg $d21;

        if $b16 >= 0 goto label34;

        $r4 = <org.apache.commons.math3.analysis.solvers.BaseSecantSolver$1: int[] $SwitchMap$org$apache$commons$math3$analysis$solvers$AllowedSolution>;

        $r3 = r0.<org.apache.commons.math3.analysis.solvers.BaseSecantSolver: org.apache.commons.math3.analysis.solvers.AllowedSolution allowed>;

        $i6 = virtualinvoke $r3.<org.apache.commons.math3.analysis.solvers.AllowedSolution: int ordinal()>();

        $i7 = $r4[$i6];

        tableswitch($i7)
        {
            case 1: goto label20;
            case 2: goto label21;
            case 3: goto label24;
            case 4: goto label27;
            case 5: goto label30;
            default: goto label33;
        };

     label20:
        return d3;

     label21:
        if z0 == 0 goto label22;

        $d22 = d3;

        goto label23;

     label22:
        $d22 = d12;

     label23:
        return $d22;

     label24:
        if z0 == 0 goto label25;

        $d23 = d12;

        goto label26;

     label25:
        $d23 = d3;

     label26:
        return $d23;

     label27:
        $b9 = d4 cmpg 0.0;

        if $b9 > 0 goto label28;

        $d24 = d3;

        goto label29;

     label28:
        $d24 = d12;

     label29:
        return $d24;

     label30:
        $b8 = d4 cmpl 0.0;

        if $b8 < 0 goto label31;

        $d25 = d3;

        goto label32;

     label31:
        $d25 = d12;

     label32:
        return $d25;

     label33:
        $r5 = new org.apache.commons.math3.exception.MathInternalError;

        specialinvoke $r5.<org.apache.commons.math3.exception.MathInternalError: void <init>()>();

        throw $r5;

     label34:
        goto label03;
    }

    public static void <clinit>()
    {
        <org.apache.commons.math3.analysis.solvers.BaseSecantSolver: double DEFAULT_ABSOLUTE_ACCURACY> = 1.0E-6;

        return;
    }
}
